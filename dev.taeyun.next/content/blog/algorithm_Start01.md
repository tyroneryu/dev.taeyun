---
title: 'Algorithm #01 - Start 01'
description: 'SW 문제 해결 역량의 개념과 필요성, 알고리즘 복잡도 분석과 빅오 표기법, 표준 입출력 방식, 진수와 진법 변환 원리를 정리한다.'
image: '/images/blog/portfolio-algorithm.png'
tags: 'Algorithm, Complexity, IO, Number System, Big-O'
created: '2024-02-04'
---


# Start
## 학습목표
- SW 문제 해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 이해함
- 효율적인 알고리즘의 필요성을 이해하고 알고리즘의 성능 측정 방법 중 하나인 시간 복잡도에 대해 이해함
- 프로그램을 작성하기 위한 기본 중 표준 입출력 방법에 대해 이해함
- 비트 수준의 연산과 알고리즘에 대해 이해함
- 컴퓨터에서의 실수 표현 방법에 대해 이해함

## SW 문제 해결
- 코딩 교육 이슈
    - 오바마 대통령 - 모든 학생들에게 균등한 컴퓨터 교육 기회가 제공되어야 한다고 연설(2010년)
    - 핀란드 - 초등학교 SW 코딩 교육 도입. 학생 모두를 프로그래머로 키우는 것이 목표가 아니라 컴퓨터의 작동 원리를 이해하도록 돕는 것이 목적
    - 영국 - 6세부터 15세 사이의 학생들. 컴퓨터 프로그램을 제작하는 전문적 교육 과정에 초점
    - 중국 - 2001년 코딩 교육 의무 교육 시작. 초등학교 3학년 ~ 중학교 3학년 학생들은 연간 70시간 이상의 코딩 교육. 고등학교 인공 지능 수업을 필수

### 프로그래밍하기 위한 제약 조건과 요구 사항
- 프로그래밍 언어의 특성
- 프로그램이 동작할 HW와 OS에 관한 지식
- 라이브러리들의 유의 사항들
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드
- ...

### SW 문제 해결 역량이란
- 프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료 구조, 알고리즘에 대한 지식을 적재적소에 퍼즐 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있음
- 문제 해결 역량은 추상적인 기술임
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없음
    - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않음
- 문제 해결 역량을 향상시키기 위해서 훈련이 필요함
- 문제 해결 능력을 훈련하기 위해서는
    - 일부 새로운 언어, 프레임 워크, 개발 방법론만을 배워나가는 것만으로 충분하지 않음
    - 경험을 통해서 나아지리라 막연히 짐작만 함. 그러나 경험에서는 문제 해결 능력을 개발 할 수 있는 상황이 항상 주어지는 것이 아니며 또한 그런 상황에서 자기 개발을 하기는 쉽지 않음
    - 상황을 인위적으로 만들어 훈련해야 함. 즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 나가면서 문제 해결 능력을 향상 시킬 수 있는 훈련이 필요함

### 문제 해결 과정
1. 문제를 읽고 이해함
2. 문제를 익숙한 용어로 재정의함
3. 어떻게 해결할지 계획을 세움
4. 계획을 검증
5. 프로그램으로 구현
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아봄

- 문제 해결 전략
    - 직관과 체계적인 접근
- 체계적인 접근을 위한 질문들
    - 비슷한 문제를 풀어본 적이 있던가?
    - 단순한 방법에서 시작할 수 있을까?
    - 문제를 단순화 할 수 있을까?
    - 그림으로 그려 볼 수 있을까?
    - 수식으로 표현 할 수 있을까?
    - 문제를 분해 할 수 있을까?
    - 뒤에서부터 생각해서 문제를 풀 수 있을까?
    - 특정 형태의 답만을 고려할 수 있을까?
    - ...

## 복잡도 분석
### 알고리즘?
- (명) 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법임. 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라 볼 수 있음
- 예를 들어 1부터 100까지의 합을 구하는 문제를 생각해 보자

### 알고리즘의 효율
- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는가를 말함
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는가를 말함
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 됨
    - 복잡도가 높을수록 효율성은 저하됨

#### 시간적 복잡도 분석
- 하드웨어 환경에 따라 처리 시간이 달라짐
    - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속 기능 유무
    - 입출력 장비의 성능, 공유 여부
- 소프트웨어 환경에 따라 처리 시간이 달라짐
    - 프로그램 언어의 종류
    - 운영 체제, 컴파일러의 종류
- 이러한 환경적 차이로 인해 분석이 어려움

### 복잡도의 점근적 표기
- 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식임
- 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용함
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - O(Big - Oh) -표기
    - Omega(Big - Omega) -표기
    - Theta(Big - Theta) -표기

### O(Big - Oh) -표기
- O -표기는 복잡도의 점근적 상한을 나타냄
- 복잡도가 f(n) = 2n^2 - 7n + 4 이라면, f(n)의 O-표기는 O(n^2)임
- 먼저 f(n)의 단순화된 표현은 n^2임
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨 (단, c > 0)
- 빅오 표기법의로 표현하면?
```python
n = int(input())

for i in range(n):
    print(i, end = ' ')

for i in range(n):
    print(i, end = ' ')

for i in range(n):
    print(i, end = ' ')
```
- O(n)
```python
n = int(input())

for i in range(n):
    for x in range(n):
        print(i, end = ' ')

    for y in range(n):
        print(i, end = ' ')
```
- O(n^2)
```python
n = int(input())

for i in range(50):
    print(i)
```
- O(1)
- 빅O 표기법을 이렇게 표기하기도 함
    - O(5N)
    - 5배수 강조해서 표현하고 싶은 경우, O(N)이라고 적지 않고, O(5N)이라고 적곤 함
- 빅O 표기법으로 성능 비교하기
    - 어떤 알고리즘이 더 좋은 성능을 낼까
    - O(N) vs O(N^2)
    - O(N)이 효율적

#### 자주 사용하는 O-표기
- O(1): 상수 시간 (Constant time)
- O(logn): 로그(대수) 시간 (Logarithmic time)
- O(n): 선형 시간 (Linear time)
- O(nlogn): 로그 선형 시간 (Log - linear time)
- O(n^2): 제곱 시간 (Quadratic time)
- O(n^3): 세제곱 시간 (Cubic time)
- O(logN) 은 O(1) 보다는 느리지만, 유사한 성능을 보임
- O(NlogN) 은 O(N) 보다는 느리지만, 유사한 성능을 보임

#### [정리] 복잡도 분석
- 왜 효율적인 알고리즘이 필요한가
    - 10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬함

|O(n^2)|1000|1백만|10억|
|:---:|:---:|:---:|:---:|
|PC|< 1초|2시간|300년|
|슈퍼컴|< 1초|1초|1주일|

|O(nlogn)|1000|1백만|10억|
|:---:|:---:|:---:|:---:|
|PC|< 1초|< 1초|5분|
|슈퍼컴|< 1초|< 1초|< 1초|
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음
- 값비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적임

## 표준 입출력
### Python3 표준 입출력
- 입력
    - Raw 값의 입력: `input()`
        - 받은 입력값을 문자열로 취급
    - Evaluated된 값 입력: `eval(input())`
        - 받은 입력값을 평가된 데이터 형으로 취급
- 출력
    - `print()`
        - 표준 출력 함수
        - 출력값의 마지막에 개행 문자 포함
    - `print('text', end = '')`
        - 출력 시 마지막에 개행 문자 제할 시
    - `print('%d' % number)`
        - Formatting 된 출력

### 파일의 내용을 표준 입력으로 읽어오는 방법
- `import sys`
- `sys.stdin = open('a.txt', 'r')`
```python
import sys
sys.stdin = open('input.txt', 'r')
sys.stdin = open('output.txt', 'w')

text = input()
print(text)
```
- Python3 소스 코드
```python
import sys
sys.stdin = open('input.txt', 'r')

T = int(input())

r, c = map(int, input().split())

field = []
for i in range(0, r):
    row = input()
    field.append(row)

print(T)
print(str(r) + ' ' + str(c))
for i in range(0, r):
    print(field[i])
```
- `map(int, input().split())`: 한 줄 입력 받아서 공백 기준으로 나누고, 정수로 형 변환

## 진수(진법)
### 2진수, 8진수, 16진수, 10진수
- 10진수 (DEC): 사람이 사용하는 진수, 수 하나를 0 ~ 9로 표현
- 2진수 (BIN): 컴퓨터가 사용하는 진수, 수 하나를 0, 1로 표현
- 8진수 (OCT): 2진수를 더 가독성 있게 사용
- 16진수 (HEX): 2진수를 더 가독성 있게 사용, 수 하나를 0, 1, ..., 8, 9, A, B, C, D, E, F 로 표현
    - (168)10진 = (1010 1000)2진
        = (250)8진
        = (A8)16진
    - 2진수를 사람이 이해하기 편하도록, 10진수로 변환시 -> 인간이 이해하기 편하지만, **연산이 오래 걸림**
    - 2진수를 사람이 이해하기 편하도록, 16진수로 변환시 -> 인간이 이해하기 어렵지만, **연산 속도가 매우 빠름**

### 진법 변환
- 10진수 -> 타진수로 변환
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽음
- 예) 149를 2진수로 변환
```python
tar = 149
result = []

while tar != 0:
    result.append(tar % 2)
    tar //= 2

result.reverse()
print(result)
# [1, 0, 0, 1, 0, 1, 0, 1]
```
- 2진수를 10진수로 변환
    - 예) 10110 -> 2^4 2^3 2^2 2^1 2^0
        - 2^4 + 2^2 + 2^1 = 22

- 16진수 <-> 2진수 변환
    - 2진수, 10진수 간 변환은 연산이 많으나, 2진수, 16진수 간 변환은 연산이 없음
    - 진법 변환을 빠르게 할 수 있으려면 우측 진수 표를 암기하는 것을 권장
