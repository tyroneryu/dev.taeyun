---
title: 'Algorithm #02 - Start 02'
description: '비트와 바이트 개념부터 AND, OR, XOR, Shift, NOT 연산과 응용, 음수 표현 방식(2의 보수), 실수의 표현 범위와 근사 저장 원리를 정리한다.'
image: '/images/blog/portfolio-algorithm.png'
tags: 'Algorithm, Bitwise, XOR, Shift, Floating Point'
created: '2024-02-05'
---


# Start
## 비트 연산
- 비트와 바이트
    - 1bit: 0과 1을 표현하는 정보의 단위
    - 1 Byte: 8 bit를 묶어 1 Byte라고 함
- 예시
    - 1001011011011100 은 총 몇 비트, 몇 바이트인가?
    - 16 bit, 2 Byte
- 컴퓨터의 CPU는 0과 1을 다루어 동작되며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함
- 목적
    - 사람이 사용하는 사칙연산 (+, -, *, /)이 아닌 컴퓨터가 사용하는 연산인 **비트 연산**을 이해해봄
    - 프로그래밍에서 비트 연산을 활용한 코딩 방법을 익혀봄

### 비트 연산자
#### AND, OR
- a AND b: a, b 둘 다 1일때만 결과가 1임. 그외에는 0
- a OR b: a, b 둘 중 하나만 1이면 결과가 1임. 그 외에는 0

|연산자|연산자의 기능|
|:---:|:---:|
|&|비트 단위로 AND 연산을 함. 예) num1 & num2|
|ㅣ|비트 단위로 OR 연산을 함. 예) num1ㅣnum2|

- 파이썬에서 2진수, 16진수, 10진수 변환하여 출력하기
    - 2진수는 숫자 0과 소문자 b -> 0b를 접두사로 붙여 표현
    - 16진수는 숫자 0과 소문자 x -> 0x를 접두사로 붙여 표현
- 10진수를 2, 16진수로 변환
```python
print(bin(10))          # 0b1010
print(hex(10))          # 0xa
```
- 2, 16진수 문자열을 10진수로 변환
```python
print(int('1011', 2))   # 11
print(int('b', 16))     # 11
```
- 0b11011110 & 0b11011
- 0x4A3 | 25(10)
- 위 두개를 구현해보자
```python
print(0b11011110 & 0b11011) # 26
print(0x4A3 | 25)           # 1211
```

### XOR
- ^: XOR 연산자. OR처럼 동작되는데 둘 다 1인 경우는 0임

|연산자|연산자의 기능|
|:---:|:---:|
|^|비트 단위로 XOR 연산을 함.(같으면 0, 다르면 1) 예) num1 ^ num2|

```python
a = bin(0b1011 ^ 0b1101)
print(a)                # 0b110
```
#### 신기한 XOR
- 어떤 값이던 임의의 수로 2회 XOR를 하면 원래 수로 돌아옴
    - 7070 ^ 1004 = 6258
    - 6258 ^ 1004 = 7070
- 암호화에 쓰이는 XOR

- [도전] 수를 입력 받고, 암호화 해주거나(인코딩), 암호를 해제해주는 (디코딩) 프로그램을 제작함
- KEY 값은 1004로 함
```python
KEY = 1004

def encode_decode(num):
    return num ^ KEY

print(encode_decode(1000))  # 4
print(encode_decode(4))     # 1000
```

### Left와 Right Shift 연산자
- Lesft Shift <<: 특정 수 만큼 비트를 왼쪽으로 밀어냄 (우측에 0이 생성)
- Right Shift >>: 특정 수 만큼 비트를 오른쪽으로 밀어냄 (우측 비트들이 제거됨)

|연산자|연산자의 기능|
|:---:|:---:|
|<<|피연산자의 비트 열을 왼쪽으로 이동. 예) num1 << 2|
|>>|피연산자의 비트 열을 오른쪽으로 이동. 예) num1 >> 2|

```python
print(bin(0b1101 << 2))     # 0b110100
print(bin(0b1101 >> 2))     # 0b11
```
- [도전] Left Shift(<<) 를 이용한 프로그래밍
- 반복문을 이용하여 아래와 같이 출력
    - Loop 1: 0b1 출력 (2진수와 10진수로 출력)
    - Loop 2: 0b10 출력 (2진수와 10진수로 출력)
    - Loop 3: 0b100 출력 (2진수와 10진수로 출력)
    - Loop 4: 0b1000 출력 (2진수와 10진수로 출력)
    - Loop 5: 0b10000 출력 (2진수와 10진수로 출력)
```python
t = 1
for i in range(5):
    print(bin(t), t)
    t = t << 1

# 0b1 1
# 0b10 2
# 0b100 4
# 0b1000 8
# 0b10000 16
```

### 비트 연산 응용1
- 1 << n
    - 2^n의 값을 가짐
    - 임베디드 분야에서 계산을 빠르게 하기 위해 사용됨

### 비트 연산 응용2
- i & (1 << n)
    - i의 n번 비트가 1인지 아닌지를 확인할 수 있음
    - 예) 1**1**01 & (1 << 2)
    - 위 연산으로 1101에서 **2번 bit**가 1인지 확인 가능함
    1. (1 << 2)를 하면 100이 됨
    2. 이후 1101 & 0100 = 0100 이 됨
    3. 0100 은 0보다 큰 수이므로, n번 비트는 1임이 확정됨
    - 만약 결과가 0이라면 n번 비트는 0임이 확정됨
```python
t = 1101 & (1 << 2)

if t > 0:
    print('n번 bit는 1입니다')
if t == 0:
    print('n번 bit는 0입니다')
```

### 음수 표현 방법
- 컴퓨터는 음수를 **2의 보수**로 관리함
- 맨 앞자리 bit(**MSB**)는 음수 or 양수를 구분하는 비트
```python
def Bbit_point(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else: '0'
    print(output)

for i in range(-5, 6):
    print(f'{i} = ', end = '')
    Bbit_point(i)

# -5 = 11111011
# -4 = 11111100
# -3 = 11111101
# -2 = 11111110
# -1 = 11111111
# 0 = 00000000
# 1 = 00000001
# 2 = 00000010
# 3 = 00000011
# 4 = 00000100
# 5 = 00000101
```
- 2의 보수 예시
- 10001의 2의 보수
    - 수를 모두 뒤집고 +1을 함
    - 01110 + 1 = 01111
- 1111000의 2의 보수
    - 수를 뒤집으면 0000111이고 +1을 함
    - 0000111 + 1 = 0001000

#### 신기한 2의 보수
- 2의 보수를 취한 수를 한번 더 2의 보수를 취하면 **원래의 값으로 돌아옴**
- 10001의 2의 보수
    - 수를 모두 뒤집고 +1을 함
    - 01110 + 1 = 01111
- 01111의 2의 보수
    - 10000 + 1 = 10001
- -5를 2의 보수로 표현하는 방법 (가정: 수를 8bit로 저장하는 경우)
    - 수 5를 2진수로 나타내면 000 0101임 (7bit)
    - -5는 음수이기에 MSB는 1임
    - 나머지 7bit에 대해 수를 뒤집고 1을 더하면 됨 (2의 보수)
    - 수 5를 뒤집으면 111 1010이며, 1을 더하면 111 1011이 됨
    - 따라서  1111 1011이 됨

### NOT 연산자
- NOT 연산자 ~: 모든 비트를 반전 시킴
- 만약 8bit일 때 ~(0001 1111)이라면 값은 1110 0000이 됨
- 파이썬에서 ~4를 수행하면 -5가 출력됨
    - 4는 0b0100임 (MSB: 양수이므로)
    - NOT 연산자로 인해 뒤집으면 1011이 됨
    - MSB는 1이 되었고 (음수), 나머지 bit는 011임
    - 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101이므로 5가 됨
    - 따라서 -5가 됨
```python
print(~4)   # -5
```

#### [도전] 비트연산 문제 풀어보기
- 정수 N, M이 주어질 때, M의 이진수 표현의 마지막 N 비트가 모두 1로 켜져 있는지 아닌지를 판별하여 출력, 모두 켜져있다면 ON 출력, 아니면 OFF 출력
- ex)
    - 5 31
    - 31을 이진수는 0001 1111임
    - 5개 bit로 모두 1로 켜져있음
    - 정답은 ON
```python
M = 31
N = 5
def Test():
    tar = M
    for i in range(N):
        if tar & 0x1 == 0:
            return False
        tar = tar >> 1
    return True

print(Test())
```

## 실수
- 파이썬에서 실수 출력 방법
- f-string 문법을 지향함
```python
t1 = 10
t2 = 3.141592

print(f'변수 값을 {t1} 입니다')
print(f'변수 값은 {t2:.2f} 입니다')     # 소수:.n : 소수 n자리까지 반올림
```

### 실수 표현 범위
- 파이썬에서는 다른 언어와 달리 내부적으로 더 큰 규모의 자료구조를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있음
- 최대로 표현할 수 있는 값은 약 1.8 X 10^308 이고 이 이상은 inf로 표현
- 최소로 표현할 수 있는 값은 약 5.0 X 10^-324이며, 이 이하는 0으로 표현
- 컴퓨터는 실수를 내부적으로 근사적으로 관리함
    - 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이 때 생기는 작은 오차가 계산 과정에서 다은 결과를 가져옴
    - `print(0.1 + 0.1 + 0.1 == 0.3)    # False`

#### [도전] 실수 값 출력해보기
- 0.1이 정확히 어떤 값으로 저장되어 있는지 f-string을 이용하여 출력해보자
- 소수점 20자리 이상으로도 출력해보자
```python
t = 0.1
print(f'{t:.2f}')       # 0.10
```

### 근사 값으로 저장되는 원리
- 소수점이 있는 10진수를 2진수로 변환 예시

|2진수|1진수|
|:---:|:---:|
|2^-5|0.03125|
|2^-4|0.0625|
|2^-3|0.125|
|2^-2|0.25|
|2^-1|0.5|
|2^0|1|

- 0.75 = 2^-1 + 2^-2 = 0.11
- 0.40625 = 2^-2 + 2^-3 + 2^-5 = 0.01101
