---
title: 'Algotihm #03 - Computational Thinking'
description: '프로그래밍에 필요한 Hard Logic과 Soft Logic의 차이, 카드·맥주집 문제, 증명 오류 사례, 소프트 로직과 하드 로직의 구분 필요성을 정리합니다.'
image: '/images/blog/portfolio-algorithm.png'
tags: 'Computational Thinking, Logic, Proof, Math, Programming'
created: '2024-02-06'
---


# Computational Thinking
## 프로그래밍과 논리/수학
- 프로그래밍이 초보자에게 어렵게 느껴지는 두가지 이유
    1. 초보자에게 복잡해 보이는 프로그래밍 언어 문법, 복잡한 라이브러리 사용
    2. 논리(Hard Logic)

### 논리학
- 논리는 두가지가 있음
1. Hard Logic
2. Soft Logic
- 하드로직과 스프트로직을 구분을 해보기 위해 먼저, 두가지 문제를 풀어보자
    - 카드문제
    - 맥주집 문제

#### 카드 문제
- 사실: 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써있음
- 주장: 만약 한 쪽이 D인 경우, 반대쪽은 3이 적혀있을 것
- 위 주장이 사실인지, 아래 카드를 직접 뒤집어 보면서 확인하고자 함
- 주장의 참과 거짓을 증명하기 위해, 반드시 뒤집어 봐야 하는 카드는 무엇인가    
![Card01](./asset/Card01.PNG)
- 답: [D]와 [7]
- [D]를 뒤집었을 때, 3이 안나오면 거짓을 증명 가능
- [3]을 뒤집었을 때, D가 있더라도 주장이 참임을 확신할 수 없음
- 이것 하나로 모든 D카드 반대쪽에는 3이 적혀있다는 것을 보장할 수 없음
- [7]을 뒤집었을 때, D가 있다면 거짓을 증명할 수 있음

#### 맥주집 문제
- 맥주집의 규칙: 20세 이하인 사람은 맥주를 마실 수 없음
- 사실: 나이 or 마시고 있는 것이 표시되어 있음
- 규칙이 잘 지켜지고 있는지 확인하고자 한다면 다음 4명 중 확인이 필요한 것은 누구인가       
![Beer01](./asset/Beer01.PNG)
- 답: [17세], [맥주]

#### 카드 문제 vs 맥주집 문제
- 맥주집 문제가 더 풀기 쉽게 느껴지겠지만 사실, 두 문제는 완전히 같은 문제임
- 논리적 구성은 완전히 동일함
- 만약 맥주집 문제가 더 쉽다고 느껴진다면 맥주집 문제를 풀 때 논리를 사용한 것이 아님

### Soft Logic
- 맥주집 문제를 풀 때는 직관을 사용한 것
- 직관은 논리적인 느낌을 주는 것 == Soft logic
- 직관이 나쁜건 아님
    - 직관의 장점은 (익숙한 상황에서)빠르다는 것
- 직관의 단점은 정확하지 않다는 것 (가끔은 익숙한 상황에서도 틀림)
    - 그리고 강한 착각을 일으킨다는 것
- 직관적인 논리와, 진짜 논리를 구분해야 하는 이유
    - 진짜 논리가 아닌 직관적인 논리를 사용하면 논리적 오류가 발생함
    - 진짜 논리가 약한 사람은 이것이 잘못되었는지 파악조차 못함

#### 토플과 복권
- 합격하려면 토플 500점 이상 **혹은** 토익 600점 이상이 필요
- 복권에 당첨되면 자동차 **혹은** 천만원을 줌
- Inclusive OR: 첫번째는 둘 중에 하나만 있으면 합격, 그리고 둘 다 있어도 합격이라는 뜻
- Exclusive OR: 두번째는 둘 중에 하나만 준다는 것이고, 둘 다 준다는 것이 아님

- 일상 생활에서는 Soft Logic이 빠르기 때문에 유용
    - 논리적으로 부정확한 표현을 사용하더라도 어떤 의미인지는 알고 있을 것이라고 생각하고 넘어감
- 프로그래밍은 Hard Logic을 사용
    - 직관적인 논리로 프로그래밍을 하면, 프로그램이 동작을 안할 것
    - 프로그래밍 언어의 표현들은, 모두 논리학에서 나온 것
    - Soft Logic으로 알고리즘을 이해하려 하면 안됨
    - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic 이 필요

### 증명
- 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
- 증명에 대한 수많은 오해가 p -> q를 p <-> q와 혼동하는 것에서 일어남
- 모든 당구공은 색이 같다는 다음 증명에서 잘못된 것은?
    - 수학적 귀납법: P(1)이 참이고, P(n) -> P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참
    - 모든 자연수 n에 대해 당구공 n개가 들어있는 집합에서 그 집합에 포함된 당구공은 모두 색이 같다는 것을 증명함
    - P(1): 당구공 1개가 들어있는 집합은 모두 색이 같음
    - P(n) -> P(n + 1)을 증명하기 위해 P(n)이 참이라고 가정
    - 당구공 n + 1개가 들어 있는 임의의 집합을 생각함
    - 이 집합에서 하나를 빼면 당구공 n개가 있는 집합이 되므로 지금 상황에서 모든 당구공의 색이 같음
    - 방금 뺀 원소를 다시 넣고, 다른 당구공을 빼면 역시 당구공 n개가 있는 집합이 되므로 지금 상황에서도 모든 당구공의 색이 같음
    - 위의 두 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n + 1개가 들어 있는 임의의 집합은 색이 같은 것만을 포함
- 대부분의 사람들이 P(n)이 참이라고 가정할 수 없다고 반론함
- 수학적 귀납법에서 필요한 것은 P(n) -> P(n + 1)이 참임을 보이는 것 뿐이므로 P(n)이 정말로 참일 필요는 없음
- 위 증명에서 실제로 잘못된 것은 '위의 두 상황에서 처음 뺀 당구공은...'
- 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같다는 것은 공통 부분이 있다는 것인데, 실제로 n = 1인 경우, 즉 n + 1 = 2인 경우 공통 부분이 없음
----
- Prime Number의 개수는 무한히 많다는 다음 증명은 옳은가
    - Prime Number의 개수가 유한한 k개라고 가정
    - 모든 Prime Number를 다 곱하고 1을 더한 수를 n이라고 하자
    - 이 수 n은 어떤 Prime으로 나누어도 나머지가 1임
    - 그런데 n은 어떤 Prime보다도 크므로 합성수임
    - 합성수이지만 어떤 Prime으로도 나누어지지 않으므로 모순 발생
- 이 증명에 대한 반론으로 몇 개의 Prime이 더 존재하면 되는 것이 아니냐는 주장이 자주 있음
- 위 증명은 'Prime Number가 k개이면 모순이 발생' 
- 즉, 'Prime Number가 k개' -> '항상 거짓' 이 명제가 항상 참임을 확인할 것
- 즉, Prime Number가 K개 라는 명제가 항상 거짓일 수 밨에 없음
